let contract;
let signer;

const contractAddress = '0x830CC57aA0A99dc7F8C3154f7c5F58cED390aAbe';
const contractABI = [
    "function createInvoice(address recipient, uint256 amount) public returns (uint256)",
    "function payInvoice(uint256 tokenId) public payable",
    "function listInvoiceForSale(uint256 tokenId, uint256 salePrice) public",
    "function buyInvoice(uint256 tokenId) public payable",
    "function getInvoiceDetails(uint256 tokenId) public view returns (uint256, address, address, bool, bool, uint256)",
    "event InvoiceCreated(uint256 indexed tokenId, uint256 amount, address indexed issuer, address indexed recipient)"
];

async function connectWallet() {
    if (typeof window.ethereum !== 'undefined') {
        try {
            await ethereum.request({ method: 'eth_requestAccounts' });
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();
            contract = new ethers.Contract(contractAddress, contractABI, signer);
            console.log('Wallet connected');
            updateStatusMessage('Wallet connected successfully');
            await fetchInvoices();
        } catch (error) {
            console.error('Failed to connect wallet:', error);
            updateStatusMessage('Failed to connect wallet. Please try again.');
        }
    } else {
        updateStatusMessage('Please install MetaMask!');
    }
}

async function createInvoice(event) {
    event.preventDefault();
    const recipient = document.getElementById('recipient-address').value;
    const amountRands = document.getElementById('amount-rands').value;
    const amountWei = ethers.utils.parseEther(amountRands);

    try {
        updateStatusMessage('Creating invoice... Please wait.');
        const tx = await contract.createInvoice(recipient, amountWei);
        console.log('Transaction sent:', tx.hash);
        const receipt = await tx.wait();
        console.log('Invoice created:', receipt);
        updateStatusMessage('Invoice created successfully!');
        await fetchInvoices();
    } catch (error) {
        console.error('Error creating invoice:', error);
        updateStatusMessage('Error creating invoice. Please try again.');
    }
}

function updateStatusMessage(message) {
    document.querySelector('.status-message').textContent = message;
}

async function fetchInvoices() {
    console.log('Fetching invoices...');
    const invoicesContainer = document.querySelector('.invoice-list');
    invoicesContainer.innerHTML = '<h2>Your Invoices</h2>';

    try {
        const userAddress = await signer.getAddress();
        console.log('User address:', userAddress);
        
        let tokenId = 0;
        let foundInvoices = false;

        while (tokenId < 100) { // Limit to prevent infinite loop
            try {
                console.log('Fetching invoice details for token ID:', tokenId);
                const [amount, issuer, recipient, paid, forSale, salePrice] = await contract.getInvoiceDetails(tokenId);
                console.log('Invoice details:', { tokenId, amount, issuer, recipient, paid, forSale, salePrice });
                
                if (issuer.toLowerCase() === userAddress.toLowerCase()) {
                    console.log('Found invoice for current user');
                    const invoiceCard = createInvoiceCard(tokenId, amount, paid, forSale, salePrice);
                    invoicesContainer.appendChild(invoiceCard);
                    foundInvoices = true;
                }
                tokenId++;
            } catch (error) {
                console.log('Error fetching invoice details for token ID', tokenId, ':', error.message);
                break; // Exit the loop if we encounter an error (likely means we've reached the end of valid token IDs)
            }
        }

        if (!foundInvoices) {
            invoicesContainer.innerHTML += '<p>No invoices found.</p>';
        }
    } catch (error) {
        console.error('Error fetching invoices:', error);
        updateStatusMessage('Error fetching invoices. Please try again.');
    }
}

function createInvoiceCard(tokenId, amount, paid, forSale, salePrice) {
    const card = document.createElement('div');
    card.className = 'invoice-card';
    card.innerHTML = `
        <p><strong>Token ID:</strong> ${tokenId}</p>
        <p><strong>Amount:</strong> R${ethers.utils.formatEther(amount)}</p>
        <p><strong>Status:</strong> ${paid ? 'Paid' : 'Unpaid'}</p>
        ${!paid && !forSale ? `<button class="list-sale-btn" onclick="listForSale(${tokenId})">List for Sale</button>` : ''}
    `;
    return card;
}

async function listForSale(tokenId) {
    const salePrice = prompt("Enter the sale price in Rands:");
    if (salePrice === null) return;

    const salePriceWei = ethers.utils.parseEther(salePrice);
    try {
        const tx = await contract.listInvoiceForSale(tokenId, salePriceWei);
        updateStatusMessage('Listing invoice for sale... Please wait.');
        await tx.wait();
        updateStatusMessage('Invoice listed for sale successfully!');
        await fetchInvoices();
    } catch (error) {
        console.error('Error listing invoice for sale:', error);
        updateStatusMessage('Error listing invoice for sale. Please try again.');
    }
}

window.addEventListener('load', connectWallet);

// Listen for 'InvoiceCreated' events
if (contract) {
    contract.on("InvoiceCreated", (tokenId, amount, issuer, recipient) => {
        console.log('Invoice created event:', { tokenId, amount, issuer, recipient });
        fetchInvoices();
    });
}
